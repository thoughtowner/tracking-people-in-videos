<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Обнаружение людей на видео</title>
  <style>
    body { font-family: sans-serif; padding: 20px; max-width: 800px; margin: auto; }
    button, input[type="file"] { margin: 10px 0; }
    #controls, #syncMode, #downloadMode { margin-top: 20px; }
    canvas { border: 1px solid black; margin: 10px; }
    .row { display: flex; justify-content: center; gap: 20px; }
    .hidden { display: none; }
  </style>
</head>
<body>

  <h1>Обнаружение людей на видео</h1>

  <div id="controls">
    <input type="file" id="fileInput" accept="video/mp4">
    <button onclick="uploadVideo()">Загрузить видео</button>
    <div id="status" style="color: darkred;"></div>
  </div>

  <p id="modeText" style="display:none;">Выберите режим:</p>
  <button onclick="selectMode('sync')" id="syncButton" style="display:none;">Воспроизведение в реальном времени</button>
  <button onclick="selectMode('download')" id="downloadButton" style="display:none;">Скачать обработанное видео</button>

  <button id="sync_play_button" class="hidden">Переключить режим воспроизведения</button>

  <div id="syncMode" style="display:none;">
    <div class="row">
      <div>
        <p>Оригинальное видео</p>
        <video id="originalVideo" style="display:none;" width="640" height="480"></video>
        <canvas id="originalCanvas" width="640" height="480"></canvas>
      </div>
      <div>
        <p>Обработанное видео</p>
        <canvas id="processedCanvas" width="640" height="480"></canvas>
      </div>
    </div>
  </div>

  <div id="downloadMode" style="display:none;">
    <p id="downloadText" style="display:none;">Ссылка для скачивания появится после обработки видео:</p>
    <a id="downloadLink" href="#" download="processed_video.mp4" style="display:none;">Скачать обработанное видео</a>
    <p id="detectionsText" style="display:none;">Ссылка на координаты:</p>
    <a id="detectionsLink" href="#" target="_blank" style="display:none;">Смотреть координаты обнаруженных объектов</a>
  </div>

  <script>
    let mode = null;
    let ws = null;
    let videoId = null;
    let uploadedVideo = null;

    function showModeButtons() {
      document.getElementById("modeText").style.display = "block";
      document.getElementById("syncButton").style.display = "inline-block";
      document.getElementById("downloadButton").style.display = "inline-block";
    }

    function selectMode(selected) {
      mode = selected;
      document.getElementById("syncMode").style.display = selected === "sync" ? "block" : "none";
      document.getElementById("downloadMode").style.display = selected === "download" ? "block" : "none";

      if (uploadedVideo) {
        if (selected === "download") {
          document.getElementById("downloadText").style.display = "block";
          document.getElementById("downloadLink").style.display = "block";
          document.getElementById("downloadLink").href = `/video?video_id=${videoId}`;
          document.getElementById("detectionsText").style.display = "block";
          document.getElementById("detectionsLink").style.display = "block";
          document.getElementById("detectionsLink").href = `/detections?video_id=${videoId}`;
        } else if (selected === "sync") {
          playSync(uploadedVideo, videoId);
        }
      }
    }

    async function uploadVideo() {
      const fileInput = document.getElementById("fileInput");
      const file = fileInput.files[0];
      if (!file) {
        alert("Выберите видеофайл.");
        return;
      }

      const formData = new FormData();
      formData.append("video", file);

      const status = document.getElementById("status");
      status.textContent = "Загрузка и обработка...";

      try {
        const response = await fetch("/track", {
          method: "POST",
          body: formData
        });
        const data = await response.json();
        videoId = data.video_id;
        uploadedVideo = file;

        status.textContent = "Видео загружено и обработано.";

        showModeButtons();
      } catch (err) {
        status.textContent = "Ошибка загрузки или обработки: " + err.message;
      }
    }

    function playSync(file, videoId) {
      const originalVideo = document.getElementById("originalVideo");
      const originalCanvas = document.getElementById("originalCanvas");
      const processedCanvas = document.getElementById("processedCanvas");
      const originalCtx = originalCanvas.getContext("2d");
      const processedCtx = processedCanvas.getContext("2d");

      const objectUrl = URL.createObjectURL(file);
      originalVideo.src = objectUrl;
      originalVideo.load();

      let lastOriginalTime = 0;
      let lastProcessedTime = 0;
      let frameInterval = 0;

      originalVideo.addEventListener("play", () => {
        requestAnimationFrame(function drawOriginal() {
          if (!originalVideo.paused && !originalVideo.ended) {
            const currentTime = originalVideo.currentTime * 1000;

            if (currentTime - lastOriginalTime >= frameInterval) {
              originalCtx.drawImage(originalVideo, 0, 0, originalCanvas.width, originalCanvas.height);
              lastOriginalTime = currentTime;
            }

            requestAnimationFrame(drawOriginal);
          }
        });
      });

      ws = new WebSocket(`ws://${window.location.host}/ws/${videoId}`);
      ws.binaryType = "blob";

      let firstFrameProcessed = false;

      ws.onmessage = (event) => {
        const blob = event.data;
        const img = new Image();
        img.onload = () => {
          const currentProcessedTime = Date.now();

          const delay = currentProcessedTime - lastProcessedTime;
          const expectedDelay = frameInterval - delay;

          if (expectedDelay > 0) {
            setTimeout(() => {
              processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
              processedCtx.drawImage(img, 0, 0, processedCanvas.width, processedCanvas.height);
              lastProcessedTime = Date.now();
              URL.revokeObjectURL(img.src);

              if (!firstFrameProcessed) {
                originalVideo.play();
                firstFrameProcessed = true;
              }
            }, expectedDelay);
          } else {
            processedCtx.clearRect(0, 0, processedCanvas.width, processedCanvas.height);
            processedCtx.drawImage(img, 0, 0, processedCanvas.width, processedCanvas.height);
            lastProcessedTime = Date.now();
            URL.revokeObjectURL(img.src);

            if (!firstFrameProcessed) {
              originalVideo.play();
              firstFrameProcessed = true;
            }
          }
        };
        img.src = URL.createObjectURL(blob);
      };

      ws.onopen = () => {
        ws.send("start");
      };

      ws.onerror = (error) => {
        console.error("Ошибка WebSocket: ", error);
        document.getElementById("status").textContent = "Ошибка WebSocket-соединения.";
      };

      ws.onclose = () => {
        console.log("WebSocket закрыт.");
      };
    }

    document.getElementById("sync_play_button").addEventListener("click", function() {
      fetch("/toggle_playing_mode", {
        method: "POST",
        body: JSON.stringify({ client_id: videoId, mode: "sync" }),
        headers: { "Content-Type": "application/json" }
      })
      .then(response => response.json())
      .then(data => {
        if (data.status === "success") {
          console.log("Режим воспроизведения изменен");
        } else {
          console.error("Ошибка изменения режима воспроизведения");
        }
      })
      .catch(error => console.error("Ошибка сети:", error));
    });
  </script>

</body>
</html>
